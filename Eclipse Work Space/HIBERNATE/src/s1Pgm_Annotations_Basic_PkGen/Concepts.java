package s1Pgm_Annotations_Basic_PkGen;
/*

Primary key generators in Hibernate
===========================================

Introduction
==============

Identifiers in Hibernate represent the primary key of an entity. This implies the values are unique so
that they can identify a specific entity, that they aren't null and that they won't be modified.

Simple Identifiers
=====================

The most straightforward way to define an identifier is by using the @Id annotation.

Simple ids are mapped using @Id to a single property of one of these types: 
Java primitive and primitive wrapper types, String, Date, BigDecimal, BigInteger.

Let's see a quick example of defining an entity with a primary key of type long:

@Entity
public class Student {
 
    @Id
    private long studentId;
    
    // standard constructor, getters, setters
}

Generated Identifiers
======================

If we want the primary key value to be generated automatically for us, we can add the 
@GeneratedValue annotation.

This can use 4 generation types: AUTO, IDENTITY, SEQUENCE, TABLE.

If we don't specify a value explicitly, the generation type defaults to AUTO.


AUTO generation
=========================

If we're using the default generation type, the persistence provider will determine values 
based on the type of the primary key attribute. This type can be numerical or UUID.

For numeric values, the generation is based on a sequence or table generator, while UUID values 
will use the UUIDGenerator.

Let's see an example of mapping an entity primary key using AUTO generation strategy:

@Entity
public class Student {
 
    @Id
    @GeneratedValue
    private long studentId;
 
    // ...
}
In this case, the primary key values will be unique at the database level.


IDENTITY GENERATION
========================

This type of generation relies on the IdentityGenerator which expects values generated by an 
identity column in the database, meaning they are auto-incremented.

To use this generation type, we only need to set the strategy parameter:

@Entity
public class Student {
 
    @Id
    @GeneratedValue (strategy = GenerationType.IDENTITY)
    private long studentId;
 
    // ...
}
One thing to note is that IDENTITY generation disables batch updates.

SEQUENCE GENERATION (most often used)
=========================

To use a sequence-based id, Hibernate provides the SequenceStyleGenerator class.

This generator uses sequences if they're supported by our database, and switches to table 
generation if they aren't.

To customize the sequence name, we can use the @GenericGenerator annotation with 
SequenceStyleGenerator strategy:

@Entity
public class User {
    @Id
    @GeneratedValue(generator = "sequence-generator")
    @GenericGenerator(
      name = "sequence-generator",
      strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
      parameters = {
        @Parameter(name = "sequence_name", value = "user_sequence"),
        @Parameter(name = "initial_value", value = "4"),
        @Parameter(name = "increment_size", value = "1")
        }
    )
    private long userId;
    
    // ...
}
In this example, we've also set an initial value for the sequence, which means the 
primary key generation will start at 4.

SEQUENCE is the generation type recommended by the Hibernate documentation.

The generated values are unique per sequence. If you don't specify a sequence name, 
Hibernate will re-use the same hibernate_sequence for different types.

TABLE GENERATOR
=================

not often used


*/