Introduction to Messaging in guidewire
=======************************************=============================================

Messaging
================

1. Messaging is asynchronous integration mechanism in guidewire. Messages are
   triggered whenever any business data is getting changed
2. Messages are sent from the guidewire application to the external system.
3. An external system replies to the message back to the guidewire application.

Messaging is asynchronous in guidewire
=======================================
Messages are generated after the event fired rule is getting triggered. These
messages are to be sent to the destination. However the messages are not consumed
immediately once they are placed in to the table and hence the whole model of the
communication in the guidewire is asynchronous.

Physical Message table
=========================
This is xx_message table which will hold below kind of messages.
    a. Stores messages
        -Unsent messages.
        -Sent and awaiting acknowledgement messages
        -Sent and acknowledged with error messages.
If the external system is reporting some error in acknowledgement then the
guidewire application may or may not try to resend the message.

Stages of Messaging
=================================

1. An event triggers message creation.
    Newly created or changed entity is going to trigger the message creation.
    This is basically a data change which is going to trigger the message creation.

2. Payload generation.
    Application creates message and the payload is stores inside the message
    table.

3. Sending to external System
    Late binding and payload transformation
    (in java late binding refers to assignment of object to the variable only
    at the run time enabling polymorphism)

     Application checks message table for messages to send.

4. Processing acknowledgement
    External system acknowledges success or reports and error.


What are primary components of messaging
===========================================

1. Event

    a. A notification of a change.
    b. May be of interest to the external system
    c. Triggers event fired rule set.
    d. An entity has to be event aware.

2. Event fired rule set.

    a. Called for each messaging event.
    b. Generates the message payload.
    c. Creates message.

3. Message Payload

    Formatted string such as csv, xml or json.

4. Message

    Information, including payload to send to an external system in response
    to an event.


 Primary components of messaging
 =====================================

 1. Message table

    a. Stores unsent messages.
    b. Sent messages which are awaiting acknowledgement
    c. Sent and acknowledgement with error messages.

 2. Destination

    Represents external system that receives the sent messages.

 3. Messaging plugins

    a. Transforms payload.
    b. Sends the message
    c. Processes synchronous and asynchronous responses from the external
       system.

     There are 3 plugins used

     a. Request plugin
     b. Transport plugin
     c. Reply plugin

Stage 1: Triggering the message Bank Account Verification messaging triggering case study
================================================================================

Whenever a new bank account is created acme wants to verify the bank name,
routing number and account number reference to a real bank account.

Bank account is event aware entity. This can be seen in bank account entity
having the events tab. Bank account delegates to eventaware delegate.

All the entities which implements the eventaware delegate for them guidewire
automatically create specific events such as entityNameChanges, entityNameRemoved,
entityNameAdded. So here bank account entity is going to implement bankAccountAddded,
BankAccountRemoved,BankAccountChanged messaging events.

Whenever a user click update button, each bank account in the listview row
triggers an event specific to each bank account entity instance. This means
that for each bank in the list all the three messaging events that is added,removed
changed is going to get triggered.

When a user is going to add a new bank account then BankAccountAdded event is going
to get triggered. If the user is going to remove a bank account then BankAccountRemoved event
is going to triggered. Similarly if the user is going to modify the bank account then
BankAccountChanged event is going to get triggered.

Messaging destination basically refers to the external system used to reply to the
sent messages. Bank account verification is the messaging destination that subscribes to
the BankAccountAdded and BankAccountChanged events. In other words, the Bank Account
Verification messaging destination listens for when user creates a bank account and
when the user edits a bank account.

Stage2 : Generate the message payload
============================================

When an application triggers a messaging event, the application calls the EventFiredRule set.

An event fired rule set specifies root entity. The root entity represents the instance
of the entity that fired the event. Here in our case study is the BankAccount.

The message, represents the instance of the message entity. All instances of the message
are stored in the message table. A message entity has many fields. The field that stores
the content of the message is the payload field. The payload field is what the application
sends to the destination.

Payload generation is not reflected in the user interface. The Event fired rule creates
the message payload and message.

Stage 3: Sending the message
==================================================

Destination message plugins send the message.

Here the first state is to transforming message payload with the late binding.
For this we are going to write the code in the request plugin class. Here in our
case the plugin is going to be BankAccountVerificationRequest where we will write
the code isnide the method beforeSend().

beforeSend() is the method where we write the code in order to build the payload
before sending the message to the destination.

Stage 3b: Sending the message
====================================================

Here we will create a transport plugin. In the transport plugin we will write
the code inside the send() method.

send() method will have the code to send the message to the destination.

Stage 4:  Message acknowledgement
=======================================

External system is going to receive the sent message and send back a reply.

Guidewire application receives a reply and reply will determine if the isVerified field value
is verified or not.




